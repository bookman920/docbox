# 模拟系统的搭建

模拟系统由游戏服务端、游戏客户端、SPV钱包、全节点A和全节点B组成

## 启动流程

一、运行 npm run mock：
1、启动游戏服务端，在 localhost:7330/ 以JSONP模式提供支付/认证/游戏逻辑交互
2、浏览器访问 localhost:7330/ 获取模拟游戏客户端的功能页面
3、浏览器访问 localhost:7330/wallet 获取SPV钱包功能页面
4、localhost:7330/prop/:id/:mode? 提供图片访问功能

二、运行 npm start 启动本地全节点A，并配置为连接远程全节点B

三、远程运行全节点B

## 业务流程

普通流程
1、制作一个简单的APP，用以模拟游戏APP
2、制作游戏金钱包APP，支持 URL Schema 唤起方式
3、游戏APP通过 URL Schema 模式调用钱包，传递 cid 和 uid
4、钱包生成 token 对象后，带参数返回游戏APP中，或者反向 URL Schema 唤起游戏APP
5、游戏APP将令牌上传至游戏服务端，游戏服务端完成验证、绑定后，下发通知给游戏APP
6、人民币支付：
    游戏APP发起一笔人民币购买道具的模拟操作
    游戏服务端确认支付成功后，向游戏APP代表的用户转移道具(使用登录令牌中的地址信息)并下发通知
7、游戏金支付：
    游戏APP通过 URL Schema 请求钱包支付一笔费用，传递 cid（生产者编号） oid（订单号） sum（金额） 字段
    钱包确认并签发交易，查询 cid 得到发送地址，利用 OP_RETURN 写入订单号， sum 为实际发送的游戏金数值
    游戏服务端监控到订单被支付(支付到游戏应用指定地址的交易，其中的 OP_RETURN 包含正确的订单信息)后，在游戏内进行兑付，同时下发通知给游戏APP

认证流程：
1、在钱包界面，点击游戏列表
2、点击具体游戏后面的"登录"按钮，此时钱包为该游戏生成登录token，并将页面跳转到 localhost:7330/game/:tokan
3、游戏服务端捕获该路由，向全节点反向核实该token的有效性，接着设置登录状态并缓存该token，最后显示游戏客户端页面
4、游戏客户端页面上默认将显示已登录状态，以及与之相关的登录信息

支付流程：
1、用户在游戏客户端上点击"商品列表"
2、点选商品后，游戏客户端向游戏服务端发送一个请求，服务端为用户生成一笔订单，缓存在服务端
3、用户在本地全节点上，支付该订单（后续演进到在SPV钱包上执行），订单输入信息包括 游戏编号、玩家编号、原始订单号、金额：
    npm run cli rpc order.pay "'cid','uid','sn',20"
4、本地全节点成功支付后，向全网广播交易；当游戏特约全节点收到该交易，将调用游戏服务端的订单确认回调接口
5、游戏服务端收到回调请求，将订单设置为"已确认"
6、在游戏客户端上点击"订单列表"刷新订单状态，将观察到订单变为"已确认"状态

获取道具、熔铸流程：
1、在钱包界面上点击"获取道具列表"，然后点击"新增"，此时执行两笔模拟操作：a、创建了一个新的道具；b、将该道具转移到自己的地址下
2、转到本地/远程全节点控制台，将交易打包到区块并提交
3、在钱包界面上再次点击"获取道具列表"，将列表显示刚刚获得的道具
4、在道具列表中点击"熔铸"，将该道具恢复为普通硬币，此时该道具将在道具列表中消失，而可用余额增加

拍卖道具流程：
1、在钱包界面上点击"获取道具列表"，然后点击"拍卖"，此时该道具消失
2、点击"获取拍卖列表"，可以看到刚才拍卖的道具的相关交易
3、点击"竞价"，将自动提升10%报价并生成一笔新的拍卖交易，反复点击，直至达到一口价，此时拍卖交易消失
4、回到全节点控制台，将交易打包到区块并提交
5、点击"获取道具列表"，刚才拍卖的道具又回到了列表中，这是因为我们参与了拍卖交易并竞拍成功。拍卖成功后，可用余额相应降低

交易对(游戏金-比特币)：
1、A生成一个Promise，注入游戏金，申请比特币
2、B签署该Promise，承诺比特币，交易正式发布
3、A/B花费该Promise
    - 系统检测比特币如期到帐，继续等待6个确认后，批准该交易，B获得游戏金
    - 系统检测比特币并未到帐，且交易处于有效期内，则放弃后续处理
    - 系统检测比特币并未到帐，且交易失效，取消该交易，A获得返还的游戏金
